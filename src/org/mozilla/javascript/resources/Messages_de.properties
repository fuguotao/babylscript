# Translated by Gideon Zenz
#
# Default JavaScript messages file.
#


# This is replaced during jar assembly from property string
# and should not be translated
implementation.version = @IMPLEMENTATION.VERSION@


#
# To add JavaScript error messages for a particular locale, create a
# new Messages_[locale].properties file, where [locale] is the Java
# string abbreviation for that locale.  For example, JavaScript
# messages for the Polish locale should be located in
# Messages_pl.properties, and messages for the Italian Swiss locale
# should be located in Messages_it_CH.properties.  Message properties
# files should be accessible through the classpath under
# org.mozilla.javascript.resources
#
# See:
# java.util.ResourceBundle
# java.text.MessageFormat
#


# SomeJavaClassWhereUsed


# Codegen
msg.dup.parms =\
   Parametername "{0}" ist doppelt vorhanden.


msg.too.big.jump =\
   Programm zu komplex: Sprungoffset zu gro\u00df.


msg.too.big.index =\
   Programm zu komplex: Interner Index \u00fcberschreitet das 64K Limit.


msg.while.compiling.fn =\
   Kodegenerierungsfehler aufgetreten beim kompilieren der Funktion "{0}": {1}


msg.while.compiling.script =\
   Kodegenerierungsfehler aufgetreten beim kompilieren des Skripts: {0}


# Context
msg.ctor.not.found =\
   Konstruktor f\u00fcr "{0}" nicht gefunden.


msg.not.ctor =\
   "{0}" ist kein Konstruktor.


# FunctionObject
msg.varargs.ctor =\
  Methode oder Konstruktor \u201c{0}\u201d mu\u00df statisch sein sowie mit der Signatur
   "(Context cx, Object[] args, Function ctorObj, boolean inNewExpr)" \
   um einen variablen Argumentenkonstruktor zu definieren.


msg.varargs.fun =\
  Methode oder Konstruktor \u201c{0}\u201d mu\u00df statisch sein sowie mit der Signatur
   "(Context cx, Scriptable thisObj, Object[] args, Function funObj)" \
   um eine variable Argumentenfunktion zu definieren.


msg.incompat.call =\
   Methode \u201c{0}\u201d wurde an inkompatiblen Objekt aufgerufen.


msg.bad.parms =\
   Nicht unterst\u00fctzter Parametertyp "{0}" in Methode "{1}".


msg.bad.method.return =\
   Nicht unterst\u00fctzter R\u00fcckgabewert "{0}" in Methode "{1}".


msg.bad.ctor.return =\
   Konstruktion von Objekten des Typs "{0}" wird nicht unterst\u00fctzt.


msg.no.overload =\
   Methode "{0}" ist mehrfach in Klasse "{1}" enthalten.


msg.method.not.found =\
   Methode "{0}" konnte in "{1}" nicht gefunden werden.


# IRFactory


msg.bad.for.in.lhs =\
   Ung\u00fcltige linke Seite der f\u00fcr..in Schleife.


msg.mult.index =\
   Nur eine Variable ist in einer f\u00fcr..in Schleife erlaubt.


msg.bad.for.in.destruct =\
   Die linke Seite der f\u00fcr..in Schleife mu\u00df ein Array der L\u00e4nge 2 sein um Schl\u00fcssel/Wert-Paare zu akzeptieren.
   
msg.cant.convert =\
   Kann nicht zu Typ "{0}" umwandeln.


msg.bad.assign.left =\
   Ung\u00fcltige Zuweisung der linken Seite.


msg.bad.decr =\
   Ung\u00fcltiger Dekrementierungsoperator.


msg.bad.incr =\
   Ung\u00fcltiger Inkrementierungsoperator.


msg.bad.yield =\
   \u201cLiefere\u201d mu\u00df in einer Funktion stehen.


msg.yield.parenthesized =\
   Der \u201cliefere\u201d Ausdruck mu\u00df in Klammern sein.


# NativeGlobal
msg.cant.call.indirect =\
   Funktion "{0}" mu\u00df direkt aufgerufen werden, nicht durch eine Funktion anderen Namens.


msg.eval.nonstring =\
   Evaluiere() auf etwas anderes als eine einfache Zeichenkette aufgerufen liefert immer nur den Wert zur\u00fcck. Ist das wirklich was du willst?


msg.eval.nonstring.strict =\
   Evaluiere() auf etwas anderes als eine einfache Zeichenkette aufzurufen ist nicht im strikten Modus erlaubt.


msg.bad.destruct.op =\
   Ung\u00fcltiger Zuweisungsoperator f\u00fcr den Destruktor.


# NativeCall
msg.only.from.new =\
   "{0}" darf nur mittels \u201cneu\u201d aufgerufen werden.


msg.deprec.ctor =\
   Der Konstruktor "{0}" ist veraltet.


# NativeFunction
msg.no.function.ref.found =\
   Es wurde kein Quellcode gefunden um die Funktionsreferenz {0} aufzul\u00f6sen.


msg.arg.isnt.array =\
   Das zweite Argument der Funktion Function.prototype.apply mu\u00df ein Array sein.


# NativeGlobal
msg.bad.esc.mask =\
   Ung\u00fcltige Umsetzungsmaske f\u00fcr die Zeichenkette.


# NativeJavaClass
msg.cant.instantiate =\
   Fehler beim Instantiieren von ({0}): Klasse {1} ist eine Schnitstelle oder Abstrakt.


msg.bad.ctor.sig =\
   Es wurde ein Konstruktor mit falscher Signatur gefunden: \
   {0} ruft {1} mit Signature {2} auf.


msg.not.java.obj =\
   Erwarte, dass Argument f\u00fcr getClass() ein Java Objekt ist.


msg.no.java.ctor =\
   Java Konstruktor f\u00fcr \u201c{0}\u201d mit den Argumenten \u201c{1}\u201d nicht gefunden.


# NativeJavaMethod
msg.method.ambiguous =\
   Die Java Methode {0}.{1}, die mit den JavaScript Argumenttypen ({2}) \u00fcbereinstimmt ist mehrdeutig. \
   m\u00f6gliche Methoden sind: {3}


msg.constructor.ambiguous =\
   Der Java Konstruktor {0}, der mit den JavaScript Argumenttypen ({1}) \u00fcbereinstimmt ist mehrdeutig. \
   M\u00f6gliche Konstruktoren sind: {2}


# NativeJavaObject
msg.conversion.not.allowed =\
   Kann nicht von {0} nach {1} umwandeln.


msg.no.empty.interface.conversion =\
   Kann nicht von {0} nach Schnitstelle {1} ohne Methoden umwandeln.


msg.no.function.interface.conversion =\
   Kann nicht Funktion {0} zu einer Schnittstelle umwandeln, da es Methoden mit unterschiedlicher Signatur beinhaltet.


# NativeJavaPackage
msg.not.classloader =\
   Konstruktor f\u00fcr \u201cPackages" erwartet ein Arugment des Typs java.lang.Classloader


# NativeRegExp
msg.bad.quant =\
   Ung\u00fcltige Gewichtung {0}


msg.overlarge.backref =\
   R\u00fcckreferenz zu gro\u00df: {0}


msg.overlarge.min =\
   Zu gro\u00dfes Minimum {0}


msg.overlarge.max =\
   Zu gro\u00dfes Maximum {0}


msg.zero.quant =\
   Null Gewichtung {0}


msg.max.lt.min =\
   Maximum {0} ist kleiner als Minimum


msg.unterm.quant =\
   Nicht beendete Gewichtung {0}


msg.unterm.paren =\
    Nicht terminierte Klammerung {0}


msg.unterm.class =\
   Nicht beendete Zeichenklasse {0}


msg.bad.range =\
   Ung\u00fcltige Spannweite in Zeichenklasse.


msg.trail.backslash =\
   Anh\u00e4ngendes \\ im regul\u00e4ren Ausdruck.


msg.re.unmatched.right.paren =\
   Unpassendes ) in regul\u00e4rem Ausdruck.


msg.no.regexp =\
   Regul\u00e4re Ausdr\u00fccke sind nicht verf\u00fcgbar.


msg.bad.backref =\
   R\u00fcckreferenz \u00fcberschreitet Anzahl der aufnehmenden Klammern.


msg.bad.regexp.compile =\
   Only one argument may be specified if the first argument to \


# Parser
msg.got.syntax.errors = \
   Kompilierung lieferte {0} syntaktische Fehler.


msg.var.redecl =\
   Typfehler: Redeklaration der Variable {0}.


msg.const.redecl =\
   Typfehler: Redeklaration der Konstante {0}
   
msg.let.redecl =\
   Typfehler: Redeklaration der Variable {0}.


msg.parm.redecl =\
   Typfehler: Redeklaration des formalen Parameters {0}.


msg.fn.redecl =\
   Typfehler: Redeklaration der Funktion {0}.


msg.let.decl.not.in.block =\
   Syntaktischer Fehler: \u201cSei\u201d Deklaration ist nicht direkt im \u201cin\u201d Block.


# NodeTransformer
msg.dup.label =\
   Doppelte Kennung.


msg.undef.label =\
   Nicht definierte Kennung.


msg.bad.break =\
   Unbeschriftetes \u201cAbbrechen\u201d mu\u00df innerhalb einer Schleife oder eines \u201cschalte\u201d sein.


msg.continue.outside =\
   \u201cFortfahren\u201d mu\u00df innerhalb einer Schleife sein.


msg.continue.nonloop =\
   \u201cFortfahren\u201d kann nur auf Kennungen von iterativen Anweisungen verweisen.


msg.bad.throw.eol =\
   Zeilenterminatoren ist nicht zwichen dem \u201cwirf\u201d Schl\u00fcsselwort und der \u201cwirf\u201d \
   Anweisung erlaubt.
  
msg.no.paren.parms =\
   Fehlendes ( vor Funktionparametern.
 
msg.no.parm =\
   Fehlender formaler Parameter.
 
msg.no.paren.after.parms =\
   Fehlende ) nach formalen Parametern.
 
msg.no.brace.body =\
   Fehlende \u2018{\u2018 vor Funktionsrumpf.
 
msg.no.brace.after.body =\
  Fehlende \u2018}\u2019 nach Funktionsrumpf.
 
msg.no.paren.cond =\
   Fehlende ( vor Bedingung.
 
msg.no.paren.after.cond =\
   Fehlende ) after Bedingung.
 
msg.no.semi.stmt =\
   Fehlendes ; vor Anweisung.
 
msg.no.name.after.dot =\
   Fehlender name nach . Operator.
 
msg.no.name.after.coloncolon =\
   Fehlender Name nach :: Operator.
 
msg.no.name.after.dotdot =\
   Fehlender Name nach .. Operator.
 
msg.no.name.after.xmlAttr =\
   Fehlender Name nach .@
 
msg.no.bracket.index =\
   Fehlende ] nach Indexausdruck.
 
msg.no.paren.switch =\
   Fehlende ( vor \u201cschalte\u201d Ausdruck
 
msg.no.paren.after.switch =\
   Fehlende ) nach \u201cschalte\u201d Ausdruck.
 
msg.no.brace.switch =\
   Fehlende \u2018{\u2018 vor \u201cschalte\u201d Rumpf.
 
msg.bad.switch =\
   Ung\u00fcltige \u201cschalte\u201d Anweisung.
 
msg.no.colon.case =\
   Fehlendes : nach \u201cFall\u201d Ausdruck.
 
msg.double.switch.default =\
   Doppelte StandardKennung in \u201cschalte\u201d Anweisung.
 
msg.no.while.do =\
  Fehlendes \u201csolange\u201d nach dem \u201causf\u00fchren\u201d Schleifenrumpf.
 
msg.no.paren.for =\
   Fehlende ( nach \u201cf\u00fcr\u201d
 
msg.no.semi.for =\
    Fehlendes ; nach \u201cf\u00fcr\u201d Schleifeninitalisierung
 
msg.no.semi.for.cond =\
   Fehlendes ; nach \u201cf\u00fcr\u201d Schleifenbedingung
   
msg.in.after.for.name =\
   Fehlendes \u2018in\u2019 nach \u2018f\u00fcr\u2019
 
msg.no.paren.for.ctrl =\
   Fehlende ) nach \u201cf\u00fcr\u201d Schleifenkontrolle
 
msg.no.paren.with =\
   Fehlende ( vor \u201cmit\u201d Anweisung
 
msg.no.paren.after.with =\
   Fehlende ) nach \u201cmit\u201d Anweisung
 
msg.no.paren.after.let =\
  Fehlende ( nach \u201csei\u201d
 
msg.no.paren.let =\
  Fehlende ) nach Variablenliste
 
msg.no.curly.let =\
   Fehlende } nach \u201csei\u201d Anweisung
 
msg.bad.return =\
   Ung\u00fcltiger R\u00fccksprung
 
msg.no.brace.block =\
   Fehlende } in zusammengesetzer Anweisung
 
msg.bad.label =\
   Ung\u00fcltige Kennung
 
msg.bad.var =\
   Fehlender Variablenname
 
msg.bad.var.init =\
   Fehlende Variableninitalisierung
 
msg.no.colon.cond =\
  Fehlender : in Bedingungsausdruck
 
msg.no.paren.arg =\
   Fehlende ) nach Argumentenliste
 
msg.no.bracket.arg =\
   Fehlende ] nach Elementliste
 
msg.bad.prop =\
   Ung\u00fcltige Eigenschafts-Id
 
msg.no.colon.prop =\
   Fehlender : nach Eigenschafts-Id
 
msg.no.brace.prop =\
   Fehlende } nach Eigenschaftsliste
 
msg.no.paren =\
   Fehlende ) in Klammerung
 
msg.reserved.id =\
   Bezeichner ist ein reserviertes Wort
 
msg.no.paren.catch =\
   Fehlende ( vor \u201cfange\u201d-Block Bedingung
 
msg.bad.catchcond =\
   Ung\u00fcltige \u201cfange\u201d-Block Bedingung
 
msg.catch.unreachable =\
  Jede \u201cfange\u201d Klause nach einem nicht qualifiziertem \u201cfange\u201d ist nicht erreichbar.
 
msg.no.brace.try =\
   Fehlende \u2018{\u2018 vor \u201cversuche\u201d-Block
 
msg.no.brace.catchblock =\
   Fehlende \u2018{\u2018 vor \u201cfange\u201d-Block Rumpf
 
msg.try.no.catchfinally =\
   \u201cversuche\u201d ohne \u201cfange\u201d oder \u201czuletzt\u201d
 
msg.no.return.value =\
 Funktion {0} gibt nicht immer einen Wert zur\u00fcck
 
msg.anon.no.return.value =\
 Anonyme Funktion gibt nicht immer einen Wert zur\u00fcck
 
msg.return.inconsistent =\
 \u201cR\u00fccksprung\u201d Anweisung ist inkonsistent mit vorheriger Benutzung.
 
msg.generator.returns =\
 Typfehler: Generatorfunktion {0} gibt einen Wert zur\u00fcck.
 
msg.anon.generator.returns =\
 Typfehler: Anonyme Generatorfunktion gibt einen Wert zur\u00fcck
 
msg.syntax =\
  Syntaktischer Fehler
 
msg.unexpected.eof =\
  Unerwartetes Dateiende
 
msg.XML.bad.form =\
  Ung\u00fcltiger XML Syntax
 
msg.XML.not.available =\
  XML runtime nicht verf\u00fcgbar
 
msg.too.deep.parser.recursion =\
  Zu tiefe Rekursion beim Parsen
 
msg.no.side.effects =\
   Anweisung hat keine Seiteneffekte
 
msg.extra.trailing.comma =\
  Ein Anh\u00e4ngendes ist nicht als ECMA-252 Objektinitalisierer zugelassen
 
msg.equal.as.assign =\
   Test f\u00fcr Gleichheit (==) irt\u00fcmlich als Zuweisung (=) geschrieben?
 
msg.var.hides.arg =\
  Variable {0} versteckt Argument.
 
msg.destruct.assign.no.init =\
   Fehlendes = in Destruktordeklaration
 
# ScriptRuntime
msg.no.properties =\
   {0} hat keine Eigenschaften.
 
msg.invalid.iterator =\
   Ung\u00fcltiger Iteratorwert
 
msg.iterator.primitive =\
   __Iterator__ gab einen Primitivwert zur\u00fcck
 
msg.assn.create.strict =\
   Zuweisung zu nicht deklarierter Variable {0}
 
msg.ref.undefined.prop =\
   Referenz zu nicht definierter Eigenschaft \u201c{0}\u201d
 
msg.prop.not.found =\
   Eigenschaft  {0} nicht gefunden.
 
msg.set.prop.no.setter =\
   Kann Eigenschaft {0} nicht setzen, da sie nur Holer hat.
 
msg.invalid.type =\
  Ung\u00fcltiger JavaScript Wert des Typs {0}
 
msg.primitive.expected =\
   Primitvtyp erwartet ({0} vorgefunden)
 
msg.namespace.expected =\
   Namensraumobjekt auf der linken Seite von :: erwartet, aber {0} gefunden.
 
msg.null.to.object =\
   \u201cNull\u201d kann nicht in ein Objekt konvertiert werden.
 
msg.undef.to.object =\
   \u201cundefiniert\u201d kann nicht in ein Objekt konvertiert werden.
 
msg.cyclic.value =\
   Zyklischer {0} Wert nicht erlaubt.
 
msg.is.not.defined =\
   \u201c{0}\u201d ist nicht definiert.
 
msg.undef.prop.read =\
   Kann Eigenschaft \u201c{1}\u201d von {0} nicht lesen
 
msg.undef.prop.write =\
   Kann Eigenschaft \u201c{1}\u201d von {0} nicht auf \u201c{2}\u201d setzen
 
msg.undef.prop.delete =\
  Kann Eigenschaft \u201c{1}\u201d von {0} nicht l\u00f6schen
 
msg.undef.method.call =\
   Kann Methode \u201c{1}\u201d von {0} nicht aufrufen
 
msg.undef.with =\
   Kann nicht \u201cmit\u201d auf {0} anwenden.
 
msg.isnt.function =\
   {0} ist keine Funktion, es ist ein {1}
 
msg.isnt.function.in =\
   Kann Eigenschaft {0} von Objekt {1} nicht aufrufen, da es keine Funktion ist, sondern \u201c{2}\u201d.
 
msg.function.not.found =\
  Kann Funktion {0} nicht finden.
 
msg.function.not.found.in =\
   Kann Funktion {0} in Objekt {1} nicht finden.
 
msg.isnt.xml.object =\
   {0} ist kein XML Objekt
 
msg.no.ref.to.get =\
  {0} ist keine Referenz zu einem gelesenen Referenzwert.
 
msg.no.ref.to.set =\
   {0} ist keine Referenz um den Referenzwert auf {1} zu setzen.
 
msg.no.ref.from.function =\
   Funktion {0} kann nicht als die linke Seite der Zuordnung \
   oder als ein Operant f\u00fcr den ++ oder -- Operator genutzt werden.
   
msg.bad.default.value =\
   Die Methode getDefaultValue() des Objekts lieferte ein Objekt zur\u00fcck.


msg.instanceof.not.object = \
   Kann InstanzVon nicht auf ein nicht-Objekt anweden.
   
msg.instanceof.bad.prototype = \
   \u201cPrototyp\u201d Eigenschaft von {0} ist kein Objekt.
   
msg.bad.radix = \
   Ung\u00fcltiger Radix {0}.


# ScriptableObject
msg.default.value =\
   Kann Standartwert f\u00fcr Objekt nicht finden.




msg.zero.arg.ctor =\
   Kann Klasse \u201c{0}\u201d, die einen Konstruktor mit Parametern hat, nicht laden.


duplicate.defineClass.name =\
   Ung\u00fcltige Methode \u201c{0}\u201d: Name \u201c{1}\u201d wird bereits benutzt.


msg.ctor.multiple.parms =\
   Kann Konstruktor oder Klasse {0} nicht definieren, da mehr \
   als ein Konstruktor mehrere Parameter hat.


msg.extend.scriptable =\
   {0} mu\u00df ScriptableObject erweitern um die Eigenschaft {1} zu definieren.


msg.bad.getter.parms =\
   Um eine Eigenschaft zu definieren mu\u00df Hohler {0} keine Parameter \
   oder einen einzelnen ScribtableObject Parameter haben.


msg.obj.getter.parms =\
   Erwarte statischen oder deligierten Hohler {0} um einen ScriptableObject Parameter zu nehmen.


msg.getter.static =\
   Hohler und Setzer m\u00fcssen beide statisch oder beide nicht statisch sein.


msg.setter.return =\
   Setzer mu\u00df den R\u00fcckgabetyp \u201cnichts\u201d haben: {0}


msg.setter2.parms =\
  Setzer mit zwei Parametern m\u00fcssen ScriptableObject als ersten Parameter nehmen.


msg.setter1.parms =\
   Erwarte Setzer mit einzelnen Parameter f\u00fcr {0}


msg.setter2.expected =\
   Erwarte, dass statischen oder deligierten Setzer {0} zwei Parameter hat.


msg.setter.parms =\
   Erwarte entweder einen oder zwei Parameter f\u00fcr den Setzer.


msg.setter.bad.type =\
   Nicht unterst\u00fctzter Parametertyp \u201c{0}\u201d in Setzer \u201c{1}\u201d


msg.add.sealed =\
   Kann nicht eine Eigenschaft zu einem versiegelten Objekt hinzuf\u00fcgen: {0}.


msg.remove.sealed =\
   Kann nicht eine Eigenschaft von einem versiegelten Objekt entfernen: {0}.


msg.modify.sealed =\
   Kann nicht eine Eigenschaft eines versiegelten Objekts modifizieren: {0}.


msg.modify.readonly =\
   Kann nicht eine nur lesbare Eigenschaft modifizieren: {0}.


# TokenStream
msg.missing.exponent =\
   Fehlender Exponent


msg.caught.nfe =\
   Fehler im Zahlenformat


msg.unterminated.string.lit =\
   Nicht terminiertes Zeichenkettenliteral


msg.unterminated.comment =\
   Nicht terminierter Kommentar


msg.unterminated.re.lit =\
   Nicht terminiertes literal in regul\u00e4rem Ausdruck.


msg.invalid.re.flag =\
   Ung\u00fcltige Markierung nach regul\u00e4rem Ausdruck.


msg.no.re.input.for =\
   Keine Eingabe f\u00fcr {0}


msg.illegal.character =\
   Ung\u00fcltiges Zeichen


msg.invalid.escape =\
   Ung\u00fcltige Unicode in Umsetzungssequenz


msg.bad.namespace =\
   Ung\u00fcltiges standard Namensraumanweisung. \
   Syntax: standard xml namensraum = AUSDRUCK;


# TokensStream warnings
msg.bad.octal.literal =\
   Ung\u00fcltige oktale literale Stelle {0}; Interpretiere als Dezimalstelle


msg.reserved.keyword =\
   Ung\u00fcltige Benutzung eines f\u00fcr die Zukunf reservierten Schl\u00fcsselwortes; \
   Interpretiere als normalen Bezeichner.


# LiveConnect errors
msg.java.internal.field.type =\
   Interner Fehler: Typumwandlung von {0} um {1} auf {2} zuzuweisen fehlgeschlagen.


msg.java.conversion.implicit_method =\
   Kann Konvertierungsmethode \u201c{0}\u201d in der Klasse {1} nicht finden.


msg.java.method.assign =\
   Java methode \u201c{0}\u201d kann nicht zugewiesen werden.


msg.java.internal.private =\
   Interner Fehler: Zugriffsversuch auf privates/gesch\u00fctztes Feld \u201c{0}\u201d.


msg.java.no_such_method =\
   Kann Methode {0} nicht finden.


msg.script.is.not.constructor =\
   Skriptobjekte sind keine Konstruktoren.


msg.nonjava.method =\
    Javamethode \u201c{0}\u201d wurde mit {1} aufgerufen, da dieser Wert \
    nicht in Java type {2} umgewandelt werden kann.


msg.java.member.not.found =\
   Javaklasse \u201c{0}\u201d hat kein \u00f6ffentliches Instanzfeld oder Methode namens \u201c{1}\u201d.


msg.java.array.index.out.of.bounds =\
   Array Index {0} ist au\u00dferhalb der Grenzen [0..{1}].


msg.java.array.member.not.found =\
   Java Arrays haben keine \u00f6ffentlichen Instanzfelder oder Methoden namens \u201c{0}\u201d.


msg.pkg.int =\
   Javapacketnamen d\u00fcrfen keine Zahlen sein.


msg.access.prohibited =\
   Zugriff auf Javaklasse \u201c{0}\u201d ist verboten.


# ImporterTopLevel
msg.ambig.import =\
   Mehrdeutiger Import: "{0}" und"{1}".


msg.not.pkg =\
   Funktion importPackage mu\u00df innerhalb eines Packetes aufgerufen werden, hatte aber \u201c{0}\u201d.


msg.not.class =\
   Funktion importPackage mu\u00df innerhalb einer Klasse aufgerufen werden, hatte aber \u201c{0}\u201d.


msg.not.class.not.pkg =\
   \u201c{0}\u201d ist weder eine Klasse noch ein Packet.


msg.prop.defined =\
   Kann \u201c{0}\u201d nicht importieren, da eine Eigenschaft diesen Namens bereits existiert.


#JavaAdapter
msg.adapter.zero.args =\
   JavaAdapter erwartet mindestens ein Argument.


msg.not.java.class.arg = \
Argument {0} ist keine Javaklasse: {1}.


#JavaAdapter
msg.only.one.super = \
Nur eine Klasse darf von einem JavaAdapter erweitert werden. Hatte {0} und {1}.




# Arrays
msg.arraylength.bad =\
   Ung\u00fcltige Arrayl\u00e4nge


# Arrays
msg.arraylength.too.big =\
  Arrayl\u00e4nge {0} \u00fcberschreitet unterst\u00fctzte Kapazit\u00e4tsgrenze.


# URI
msg.bad.uri =\
   Falsch gebildete URI Sequenz.


# Number
msg.bad.precision =\
   Pr\u00e4zision {0} ausserhalb der Reichweite.


# NativeGenerator
msg.send.newborn =\
  Versuch Wert zu neugeborenem Generator zu senden.


msg.already.exec.gen =\
   Generator wird bereits ausgef\u00fchrt.
   
msg.StopIteration.invalid =\
   StopIteration darf nicht in ein arbitr\u00e4res Objekt gewandelt werden.


# Interpreter
msg.yield.closing =\
 \u201cLiefere\u201d an geschlossenem Generator.


# New Babylscript Stuff
msg.unknown.language.mode =\
 Unbekannter Sprachmodus
