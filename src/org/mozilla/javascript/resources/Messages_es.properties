# Translation by T.M. Medina of eLYTeam
#
# Default JavaScript messages file.
#

# This is replaced during jar assembly from property string
# and should not be translated
implementation.version = @IMPLEMENTATION.VERSION@

#
# To add JavaScript error messages for a particular locale, create a
# new Messages_[locale].properties file, where [locale] is the Java
# string abbreviation for that locale.  For example, JavaScript
# messages for the Polish locale should be located in
# Messages_pl.properties, and messages for the Italian Swiss locale
# should be located in Messages_it_CH.properties.  Message properties
# files should be accessible through the classpath under
# org.mozilla.javascript.resources
#
# See:
# java.util.ResourceBundle
# java.text.MessageFormat
#

# SomeJavaClassWhereUsed

# Codegen
msg.dup.parms =\
    Nombre de par\u00e1metro duplicado "{0}".

msg.too.big.jump =\
    Programa muy complejo: salto demasiado grande.

msg.too.big.index =\
    Programa muy complejo: \u00edndice interno excede el l\u00edmite de 64K.

msg.while.compiling.fn =\
    Error de generaci\u00f3n de c\u00f3digo encontrado compilando la funci\u00f3n "{0}": {1}

msg.while.compiling.script =\
    Error de generaci\u00f3n de c\u00f3digo encontrado compilando script: {0}

# Context
msg.ctor.not.found =\
    Constructor de "{0}" no encontrado.

msg.not.ctor =\
    "{0}" no es un constructor.

# FunctionObject
msg.varargs.ctor =\
    M\u00e9todo o constructor "{0}" debe ser est\u00e1tico con la signatura \
    "(Context cx, Object[] args, Function ctorObj, boolean inNewExpr)" \
   para definir un constructor de argumentos variables.
 
msg.varargs.fun =\
   M\u00e9todo "{0}" debe ser est\u00e1tico con la signatura \
    "(Context cx, Scriptable thisObj, Object[] args, Function funObj)" \
   para definir una funci\u00f3n de argumentos variables.

msg.incompat.call =\
    M\u00e9todo "{0}" llamado en un objeto incompatible.

msg.bad.parms =\
    Par\u00e1metro de tipo "{0}" no soportado en m\u00e9todo "{1}".

msg.bad.method.return =\
    Tipo de retorno "{0}" no soportado en m\u00e9todo "{1}".

msg.bad.ctor.return =\
    Construcci\u00f3n de objetos de tipo "{0}" no soportado.

msg.no.overload =\
    M\u00e9todo "{0}" ocurre m\u00faltiples veces en la clase "{1}".

msg.method.not.found =\
    M\u00e9todo "{0}" no encontrado en "{1}".

# IRFactory

msg.bad.for.in.lhs =\
     Parte izquierda de ciclo para..en invalida.

msg.mult.index =\
    S\u00f3lo una variable es aceptada en un ciclo para..en.

msg.bad.for.in.destruct =\
    La parte izquierda de un ciclo para..en debe ser un arreglo de longitud 2 para aceptar \
    pares llave/valor.
    
msg.cant.convert =\
    No se puede convertir a tipo "{0}".

msg.bad.assign.left =\
    Asignaci\u00f3n de parte izquierde inv\u00e1lida.

msg.bad.decr =\
    Operando de decremento no v\u00e1lido.
 
msg.bad.incr =\
    Operando de incremento no v\u00e1lido.

msg.bad.yield =\
    ceder debe estar en una funci\u00f3n.

msg.yield.parenthesized =\
    la expresi\u00f3n ceder debe ser puesta entre par\u00e9ntesis.

# NativeGlobal
msg.cant.call.indirect =\
    La funci\u00f3n "{0}" debe ser llamada directamente, y no mediante una \
    una function de otro nombre.

msg.eval.nonstring =\
    Llamar eval() con cualquier otro valor que no sea una primitiva de cadena \
    simplemente retornar\u00e1 el valor. \u00bfEs esto lo qu\u00e9 pretende?

msg.eval.nonstring.strict =\
    Llamar eval() con cualquier otro valor que no sea una primitiva de cadena \
    no est\u00e1 permitido en modo estricto.

msg.bad.destruct.op =\
    Operador de destrucci\u00f3n de asignaci\u00f3n no v\u00e1lido

# NativeCall
msg.only.from.new =\
    "{0}" solo puede ser invocado desde una expresi\u00f3n \u201cnuevo\u201d.

msg.deprec.ctor =\
    El constructor "{0}" est\u00e1 discontinuado.

# NativeFunction
msg.no.function.ref.found =\
    fuente no encontrada para decompilada para decompilar la referencia de funci\u00f3n {0}

msg.arg.isnt.array =\
    el secundo argumento de Funci\u00f3n.prototype.applicar debe ser un arreglo

# NativeGlobal
msg.bad.esc.mask =\
    mascara de escape de cadena inv\u00e1lida

# NativeJavaClass
msg.cant.instantiate =\
    error creando ({0}): clase {1} es una interfaz o abstracta

msg.bad.ctor.sig =\
    Constructor con signature incorrecta encontrado: \
    {0} llamando {1} con signatura {2}

msg.not.java.obj =\
    Argumento esperado por getClass() es un objeto Java.

msg.no.java.ctor =\
    Constructor de Java para "{0}" con argumentos "{1}" no encontrado.

# NativeJavaMethod
msg.method.ambiguous =\
    La opci\u00f3n del m\u00e9todo de Java {0}.{1} correspondiente a los argumentos de Javascript de tipo ({2}) es ambigua; \
    los m\u00e9todos candidatos son: {3}

msg.constructor.ambiguous =\
    La opci\u00f3n del constructor de Java {0} correspondiente a los argumentos de Javascript de tipo ({1}) es ambigua; \
    los constructores candidatos son: {2}

# NativeJavaObject
msg.conversion.not.allowed =\
    No se puede convertir {0} a {1}

msg.no.empty.interface.conversion =\
    No se puede convertir {0} a la interfaz {1} sin ning\u00fan m\u00e9todo

msg.no.function.interface.conversion =\
    No se puede convertir  la function {0} a interfaz dado que contiene m\u00e9todos con \
    signaturas diferentes

# NativeJavaPackage
msg.not.classloader =\
    Constructor de "Packages" espera argumentos de tipo java.lang.Classloader

# NativeRegExp
msg.bad.quant =\
    Quantificador no v\u00e1lido {0}

msg.overlarge.backref =\
    Referencia hacia atr\u00e1s demasiado larga {0}

msg.overlarge.min =\
    M\u00ednimo demasiado largo {0}

msg.overlarge.max =\
    M\u00e1ximo demasiado largo {0}

msg.zero.quant =\
    Cuantificador cero {0}

msg.max.lt.min =\
    El m\u00e1ximo {0} es menor que el m\u00ednimo

msg.unterm.quant =\
    Cuantificador indeterminado {0}

msg.unterm.paren =\
    Parent\u00e9tico indeterminado {0}

msg.unterm.class =\
    Clase de caracteres indeterminada {0}

msg.bad.range =\
    Rango no v\u00e1lido en clase de caracteres.

msg.trail.backslash =\
    Buscando \\ en la expresi\u00f3n regular.

msg.re.unmatched.right.paren =\
    ) no encontrado en la expresi\u00f3n regular.

msg.no.regexp =\
    Expresiones regulares no disponibles.

msg.bad.backref =\
    Referencia hacia atr\u00e1s exceed el n\u00famero de par\u00e9ntesis capturados.

msg.bad.regexp.compile =\
    S\u00f3lo un argumento puede ser especificado si el primer argumento de \
    ExpReg.prototipo.compilar es un objeto ExpReg.

# Parser
msg.got.syntax.errors = \
    La compilaci\u00f3n provoc\u00f3 {0} errores de sintaxis.

msg.var.redecl =\
    ErrorTipo: redeclaraci\u00f3n de var {0}.

msg.const.redecl =\
    ErrorTipo: redeclaraci\u00f3n de const  {0}.
    
msg.let.redecl =\
    ErrorTipo: redeclaraci\u00f3n de variable {0}.

msg.parm.redecl =\
    ErrorTipo: redeclaraci\u00f3n del par\u00e1metro formal {0}.

msg.fn.redecl =\
    ErrorTipo: redeclaraci\u00f3n de funci\u00f3n {0}.

msg.let.decl.not.in.block =\
    ErrorSint\u00e1xis: declaraci\u00f3n dado no est\u00e1 directamente dentro de bloque

# NodeTransformer
msg.dup.label =\
    etiqueta duplicada

msg.undef.label =\
    etiqueta no definida

msg.bad.break =\
     Salir sin etiqueta debe estar dentro de un ciclo o seg\u00fan

msg.continue.outside =\
     Continuar debe estar dentro de un ciclo

msg.continue.nonloop =\
     Continuar solo puede usar etiquetas de expresiones de ciclos

msg.bad.throw.eol =\
      Finales de l\u00ednea no est\u00e1n permitidos entre la palabra clave lanzar y la expresi\u00f3n \
      lanzar.

msg.no.paren.parms =\
     ( Faltante ante de los par\u00e1metros de la funci\u00f3n.

msg.no.parm =\
     Par\u00e1metro formal faltante

msg.no.paren.after.parms =\
     ) Faltante despu\u00e9s de los par\u00e1metros formales

msg.no.brace.body =\
    '{' Faltante antes del cuerpo de la funci\u00f3n

msg.no.brace.after.body =\
    } Faltante despu\u00e9s del cuerpo de la funci\u00f3n

msg.no.paren.cond =\
    ( Faltante antes de la condici\u00f3n

msg.no.paren.after.cond =\
    ) Faltante despu\u00e9s de la condici\u00f3n

msg.no.semi.stmt =\
    ; Faltante antes de la expresi\u00f3n

msg.no.name.after.dot =\
    Nombre faltante despu\u00e9s del operador .

msg.no.name.after.coloncolon =\
    Nombre faltante despu\u00e9s del operador ::

msg.no.name.after.dotdot =\
    Nombre faltante despu\u00e9s del operador ..

msg.no.name.after.xmlAttr =\
    Nombre faltante despu\u00e9s de .@

msg.no.bracket.index =\
    ] Faltante en la expression \u00edndice

msg.no.paren.switch =\
    ( Faltante antes de la expresi\u00f3n seg\u00fan

msg.no.paren.after.switch =\
    ) Faltante despu\u00e9s de la expresi\u00f3n seg\u00fan

msg.no.brace.switch =\
    '{' Faltante antes del cuerpo de seg\u00fan

msg.bad.switch =\
    Expresi\u00f3n seg\u00fan no v\u00e1lida

msg.no.colon.case =\
    : Faltante despu\u00e9s de expresi\u00f3n caso

msg.double.switch.default =\
    doble etiqueta defecto en la expresi\u00f3n seg\u00fan

msg.no.while.do =\
    Mientras faltante despu\u00e9s del ciclo del ciclo hacer

msg.no.paren.for =\
    ( Faltante despu\u00e9s de para

msg.no.semi.for =\
    ; Faltante despu\u00e9s del inicializador del ciclo para

msg.no.semi.for.cond =\
    ; Faltante despu\u00e9s de la condici\u00f3n del ciclo para
    
msg.in.after.for.name =\
    En faltante despu\u00e9s de para

msg.no.paren.for.ctrl =\
    ) Faltante despu\u00e9s del control del ciclo para

msg.no.paren.with =\
    ( Faltante antes del objeto con expresi\u00f3n con

msg.no.paren.after.with =\
    ) Faltante despu\u00e9s del objeto con expresi\u00f3n con

msg.no.paren.after.let =\
    ( Faltante despu\u00e9s de dado

msg.no.paren.let =\
    ) Faltante despu\u00e9s de la lista de variables

msg.no.curly.let =\
    } Faltante despu\u00e9s de la expresi\u00f3n dado

msg.bad.return =\
    Retorno no v\u00e1lido

msg.no.brace.block =\
    } Faltante en expresi\u00f3n compuesta

msg.bad.label =\
    etiqueta no v\u00e1lida

msg.bad.var =\
    nombre de variable faltante

msg.bad.var.init =\
    inicializaci\u00f3n de variable no v\u00e1lida

msg.no.colon.cond =\
    : faltante en expresi\u00f3n condicional

msg.no.paren.arg =\
    ) faltante despu\u00e9s de la lista de argumentos

msg.no.bracket.arg =\
    ] faltante despu\u00e9s de la lista de elementos

msg.bad.prop =\
    identificador de propiedad no v\u00e1lido

msg.no.colon.prop =\
    : faltante despu\u00e9s de identificador de propiedad

msg.no.brace.prop =\
    } faltante despu\u00e9s de lista de propiedad

msg.no.paren =\
    ) faltante en parent\u00e9tico

msg.reserved.id =\
    identificador es una palabra reservada

msg.no.paren.catch =\
    ( faltante antes de la condici\u00f3n de capturar

msg.bad.catchcond =\
    condici\u00f3n de capturer no v\u00e1lida

msg.catch.unreachable =\
    cualquier cl\u00e1usula de capturar siguiendo una captura no calificada es inalcanzable

msg.no.brace.try =\
    '{' faltante antes del bloque tratar

msg.no.brace.catchblock =\
    '{' faltante antes del cuerpo del bloque capturar

msg.try.no.catchfinally =\
    ''tratar'' sin ''capturar' o ''finalmente''

msg.no.return.value =\
    funci\u00f3n {0} no retorna siempre un valor

msg.anon.no.return.value =\
   function an\u00f3nima no retorna siempre un valor

msg.return.inconsistent =\
   expresi\u00f3n retornar es inconsistente con su uso previo

msg.generator.returns =\
   ErrorTipo: function de generador {0} retorna un valor

msg.anon.generator.returns =\
  ErrorTipo: function de generador an\u00f3nima retorna un valor

msg.syntax =\
    error sintaxis

msg.unexpected.eof =\
    Fin de fichero inesperado

msg.XML.bad.form =\
    sintaxis de XML formada ilegalmente

msg.XML.not.available =\
    XML no disponible en tiempo de ejecuci\u00f3n

msg.too.deep.parser.recursion =\
    Recursi\u00f3n muy profunda mientras se analiza gramaticalmente

msg.no.side.effects =\
    C\u00f3digo no tiene efectos secundarios

msg.extra.trailing.comma =\
    La coma del final no es legal en la inicializaci\u00f3n de un objeto ECMA-262

msg.equal.as.assign =\
    \u00bfPrueba de igualdad (==) equivocada como asignaci\u00f3n (=)?

msg.var.hides.arg =\
    Variable {0} esconde argumento

msg.destruct.assign.no.init =\
    = faltante en la declaraci\u00f3n de la destrucci\u00f3n

# ScriptRuntime
msg.no.properties =\
    {0} no tiene propiedades.

msg.invalid.iterator =\
    Valor de iterador no v\u00e1lido

msg.iterator.primitive =\
    __iterador__ retorn\u00f3 un valor primitivo

msg.assn.create.strict =\
    Asignai\u00f3n a variable no declarada {0}

msg.ref.undefined.prop =\
    Referencia a propiedad no definida "{0}"

msg.prop.not.found =\
    Propiedad {0} no encontrada.

msg.set.prop.no.setter =\
    No se puede escribir propiedad {0} que solo tiene lector.

msg.invalid.type =\
    Valor de tipo de JavaScript  {0} no v\u00e1lido

msg.primitive.expected =\
    Tipo primitive esperado ({0} en su lugar)

msg.namespace.expected =\
    Objeto de espacio de nombre esperado a la izuqierda de :: (encontrado {0} en su lugar)

msg.null.to.object =\
    No se puede convertir de nulo a objeto.

msg.undef.to.object =\
    No se puede convertir de indefinido a objeto.

msg.cyclic.value =\
    Valor c\u00edclico {0} no permitido.

msg.is.not.defined =\
    "{0}" no est\u00e1 definido.

msg.undef.prop.read =\
    No se puede leer propiedad "{1}" de {0}

msg.undef.prop.write =\
    No se puede escribir propiedad "{1}" de {0} a "{2}"

msg.undef.prop.delete =\
    No se puede eliminar propiedad "{1}" de {0}

msg.undef.method.call =\
    No se puede llamar m\u00e9todo "{1}" de {0}

msg.undef.with =\
    No se puede aplicar "con" a {0}

msg.isnt.function =\
    {0} no es una funci\u00f3n, es {1}.

msg.isnt.function.in =\
    No se puede llamar propiedad {0} en objeto {1}. No es una funci\u00f3n, es "{2}".

msg.function.not.found =\
    No se puede encontrar la funci\u00f3n {0}.

msg.function.not.found.in =\
    No se puede encontrar la funci\u00f3n {0} en el objeto {1}.

msg.isnt.xml.object =\
    {0} no es un objeto xml.

msg.no.ref.to.get =\
    {0} no es una referencia para leer valor de referencia.

msg.no.ref.to.set =\
    {0} no es una referencia para escribir valor de referencia a {1}.

msg.no.ref.from.function =\
    Funci\u00f3n {0} no puede ser usada como el lado izquierdo de una asignaci\u00f3n \
    o como un operando de un operador ++ o --.

msg.bad.default.value =\
    M\u00e9todo de objeto getDefaultValue() retorn\u00f3 un objeto.

msg.instanceof.not.object = \
    No se puede usar instanciade en un no-objeto.

msg.instanceof.bad.prototype = \
    propiedad ''prototipo'' de {0} no es un objeto.

msg.bad.radix = \
    base ilegal {0}.

# ScriptableObject
msg.default.value =\
    No se puede encontrar valor por defecto para el objeto.

msg.zero.arg.ctor =\
    No se puede cargar la clase "{0}" que no tiene constructor sin par\u00e1metros.

duplicate.defineClass.name =\
    M\u00e9todo no v\u00e1lido "{0}": nombre "{1}" ya est\u00e1 en uso.

msg.ctor.multiple.parms =\
    No se puede definir constructor o clase {0} dado que m\u00e1s de un \
    constructor tiene multiples par\u00e1metros.

msg.extend.scriptable =\
    {0} debe extender ScriptableObject para definir la propiedad {1}.

msg.bad.getter.parms =\
    Para definir una propiedad, lector {0} debe tener cero par\u00e1metros \
    O un \u00fanico p\u00e1ramentro ScriptableObject parameter.

msg.obj.getter.parms =\
    Lector est\u00e1tico o delegado esperado {0} que tome un par\u00e1metro ScriptableObject.

msg.getter.static =\
    Lector y escritor deben ser ambos est\u00e1ticos o ninguno ser est\u00e1tico.

msg.setter.return =\
    Escritor  debe tener vac\u00edo como tipo de retorno: {0}

msg.setter2.parms =\
    Escritor de dos par\u00e1metros debe tomar como primer par\u00e1metro un ScriptableObject.

msg.setter1.parms =\
    Escritor de un solo par\u00e1metro esperado para {0}

msg.setter2.expected =\
     Escritor est\u00e1tico o delegado esperado {0} para tomar dos par\u00e1metros.

msg.setter.parms =\
    Uno o dos par\u00e1metros esperados para el escritor.

msg.setter.bad.type =\
    Par\u00e1metro de tipo "{0}" no soportado en escritor "{1}".

msg.add.sealed =\
    No se puede a\u00f1adir una propiedad a un objeto sellado: {0}.

msg.remove.sealed =\
    No se puede eliminar una propiedad de un objeto sellado: {0}.

msg.modify.sealed =\
    No se puede modificar una propiedad de un objeto sellado: {0}.

msg.modify.readonly =\
    No se puede modificar una propiedad de s\u00f3lo lectura: {0}.

# TokenStream
msg.missing.exponent =\
    exponente faltante

msg.caught.nfe =\
     error de format de n\u00famero

msg.unterminated.string.lit =\
     literal de cadena indeterminado

msg.unterminated.comment =\
    comentario indeterminado

msg.unterminated.re.lit =\
     literal de expresi\u00f3n regular indeterminado

msg.invalid.re.flag =\
    bandera no v\u00e1lida despu\u00e9s de la expresi\u00f3n regular

msg.no.re.input.for =\
    sin entrada para {0}

msg.illegal.character =\
    car\u00e1cter ilegal

msg.invalid.escape =\
    secuencia de escape Unicode no v\u00e1lida

msg.bad.namespace =\
    expresi\u00f3n de espacio de nombre por defecto no v\u00e1lida. \
    La sintaxis es: espacio de nombre de xml por defecto = EXPRESION;

# TokensStream warnings
msg.bad.octal.literal =\
     d\u00edgito literal de octal ilegal {0}; interpret\u00e1ndolo como un d\u00edgito decimal

msg.reserved.keyword =\
     uso illegal de futura palabra clave reservada {0}; interpret\u00e1ndolo como identificador ordinario

# LiveConnect errors
msg.java.internal.field.type =\
    Error interno: conversion de tipo de {0} para asignar a {1} en {2} fall\u00f3.

msg.java.conversion.implicit_method =\
    No se puede encontrar el m\u00e9todo para convertir "{0}" en clase {1}.

msg.java.method.assign =\
    M\u00e9todo de Java "{0}" no puede ser asignado.

msg.java.internal.private =\
    Error interno: intento de accede campo privado/protegido "{0}".

msg.java.no_such_method =\
    No se puede hallar el m\u00e9todo {0}.

msg.script.is.not.constructor =\
    Objetos script no son constructores.

msg.nonjava.method =\
    M\u00e9todo de Java "{0}" fue invocado con {1} como valor "este" que no puede ser convertido al tipo de Java {2}.

msg.java.member.not.found =\
    Clase de Java "{0}" no tiene campo de instancia p\u00fablico o m\u00e9todo llamado "{1}".

msg.java.array.index.out.of.bounds =\
    Indice de arreglo est\u00e1 fuera de rango [0..{1}].

msg.java.array.member.not.found =\
    Arreglos de Java no tienen campo de instancia p\u00fablicos o m\u00e9todos llamados "{0}".

msg.pkg.int =\
    Los nombres de los paquetes de Java no pueden ser n\u00fameros.

msg.access.prohibited =\
    Acceso a la clase de Java "{0}" est\u00e1 prohibido.

# ImporterTopLevel
msg.ambig.import =\
    Importaci\u00f3n ambigua: "{0}" y "{1}".

msg.not.pkg =\
    Funci\u00f3n importPackage debe ser llamada con un paquete; ten\u00eda "{0}" en su lugar.

msg.not.class =\
    Funci\u00f3n importClass debe ser llamada con una clase; ten\u00eda "{0}" en su lugar.

msg.not.class.not.pkg =\
    "{0}" no es ni una clase ni un paquete.

msg.prop.defined =\
    No se puede importar import "{0}" dado que una propiedad con ese nombre ya est\u00e1 definida.

#JavaAdapter
msg.adapter.zero.args =\
    JavaAdapter requiere al menos un argumento.

msg.not.java.class.arg = \
   Argumento {0} no es una clase de Java: {1}.

#JavaAdapter
msg.only.one.super = \
  S\u00f3lo una clase puede ser extendida por un JavaAdapter. Tiene {0} y {1}.


# Arrays
msg.arraylength.bad =\
    Longitud de arreglo inapropiada.

# Arrays
msg.arraylength.too.big =\
    Longitud de arreglo {0} exceed capacidad l\u00edmite soportada.

# URI
msg.bad.uri =\
    Secuencia de URI malformada.

# Number
msg.bad.precision =\
    Precisi\u00f3n {0} fuera de rango.

# NativeGenerator
msg.send.newborn =\
   Intento de enviar valor a generador reci\u00e9n creado

msg.already.exec.gen =\
    Generador ya est\u00e1 corriendo
    
msg.StopIteration.invalid =\
    PararItereaci\u00f3n no puede ser cambiada a un objeto arbitrario.

# Interpreter
msg.yield.closing =\
  Ceder de generador cerr\u00e1ndose

# New Babylscript Stuff
msg.unknown.language.mode =\
  Modo de language desconocido

