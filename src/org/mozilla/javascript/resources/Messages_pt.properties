# Translation by Margarida Martins
#
# Default JavaScript messages file.
#
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Rhino code, released
# May 6, 1999.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1997-1999
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Norris Boyd
#   Bob Jervis
#
# Alternatively, the contents of this file may be used under the terms of
# the GNU General Public License Version 2 or later (the "GPL"), in which
# case the provisions of the GPL are applicable instead of those above. If
# you wish to allow use of your version of this file only under the terms of
# the GPL and not to allow others to use your version of this file under the
# MPL, indicate your decision by deleting the provisions above and replacing
# them with the notice and other provisions required by the GPL. If you do
# not delete the provisions above, a recipient may use your version of this
# file under either the MPL or the GPL.
#
# ***** END LICENSE BLOCK *****


# This is replaced during jar assembly from property  string
# and should not be translated
implementation.version = @IMPLEMENTATION.VERSION@


#
# To add JavaScript error messages for a particular locale, create a
# new Messages_[locale].properties file, where [locale] is the Java
# string abbreviation for that locale.  For example, JavaScript
# messages for the Polish locale should be located in
# Messages_pl.properties, and messages for the Italian Swiss locale
# should be located in Messages_it_CH.properties.  Message properties
# files should be accessible through the classpath under
# org.mozilla.javascript.resources
#
# See:
# java.util.ResourceBundle
# java.text.MessageFormat
#


# SomeJavaClassWhereUsed


# Codegen
msg.dup.parms =\
    Nome de par\u00e2metro duplicado "{0}".


msg.too.big.jump =\
    Programa demasiado complexo: deslocamento grande demais.


msg.too.big.index =\
    Programa demasiado complexo: \u00edndice interno excede limite de 64K.


msg.while.compiling.fn =\
    Erro de gera\u00e7\u00e3o de c\u00f3digo ao compilar fun\u00e7\u00e3o "{0}": {1}


msg.while.compiling.script =\
    Erro de gera\u00e7\u00e3o de c\u00f3digo ao compilar script: {0}


# Context
msg.ctor.not.found =\
    Construtor para "{0}" n\u00e3o encontrado.


msg.not.ctor =\
    "{0}" n\u00e3o \u00e9 um construtor.


# FunctionObject
msg.varargs.ctor =\
    M\u00e9todo ou construtor "{0}" deve ser est\u00e1tico com a assinatura \
    "(Context cx, Object[] args, Function ctorObj, boolean inNewExpr)"
    para definir um construtor de argumentos vari\u00e1veis \.


msg.varargs.fun =\
    M\u00e9todo "{0}" deve ser est\u00e1tico com a assinatura \
    "(Context cx, Scriptable thisObj, Object[] args, Function funObj)" \
    para definir uma fun\u00e7\u00e3o de argumentos vari\u00e1veis.


msg.incompat.call =\
    M\u00e9todo "{0}" foi chamado num objeto incompat\u00edvel.


msg.bad.parms =\
    Par\u00e2metro inv\u00e1lido tipo "{0}" no m\u00e9todo "{1}".


msg.bad.method.return =\
   Tipo de retorno inv\u00e1lido "{0}" no m\u00e9todo" {1}".


msg.bad.ctor.return =\
    A constru\u00e7\u00e3o de objetos do tipo "{0}" \u00e9 inv\u00e1lida.


msg.no.overload =\
    M\u00e9todo "{0}" ocorre v\u00e1rias vezes na classe "{1}".


msg.method.not.found =\
    M\u00e9todo "{0}" n\u00e3o encontrado em "{1}".


# IRFactory


msg.bad.for.in.lhs =\
    Lado esquerdo inv\u00e1lido num ciclo por...em.


msg.mult.index =\
    Apenas se permite uma vari\u00e1vel num ciclo por...em.


msg.bad.for.in.destruct =\
    Lado esquerdo de um ciclo por... deve ser uma matriz de comprimento 2 para aceitar \
    um par chave/valor.
    
msg.cant.convert =\
    N\u00e3o se pode converter para tipo "{0}".


msg.bad.assign.left =\
    Lado esquerdo com atribui\u00e7\u00e3o inv\u00e1lida.


msg.bad.decr =\
    Operando de decremento inv\u00e1lido.


msg.bad.incr =\
   Operando de incremento inv\u00e1lido.


msg.bad.yield =\
    ceder deve estar numa fun\u00e7\u00e3o.


msg.yield.parenthesized =\
    Express\u00e3o ceder deve estar entre par\u00eanteses.


# NativeGlobal
msg.cant.call.indirect =\
    Fun\u00e7\u00e3o "{0}" deve ser chamada diretamente, e n\u00e3o via uma \
    fun\u00e7\u00e3o com outro nome.


msg.eval.nonstring =\
    Chamar avaliar() com algo diferente de um valor de cadeia primitivo ir\u00e1 \
    simplesmente retornar o valor. \u00c9 isso que pretende?


msg.eval.nonstring.strict =\
    Chamar avaliar() com algo diferente de um valor de cadeia primitivo n\u00e3o \u00e9 \
    permitido em modo estrito.


msg.bad.destruct.op =\
    Operador inv\u00e1lido de atribui\u00e7\u00e3o desestruturadora


# NativeCall
msg.only.from.new =\
    "{0}" apenas pode ser invocado a partir de uma "nova" express\u00e3o.


msg.deprec.ctor =\
   O construtor "{0}" \u00e9 obsoleto.


# NativeFunction
msg.no.function.ref.found =\
   n\u00e3o foi encontrada a fonte para descompilar a refer\u00eancia da fun\u00e7\u00e3o {0}


msg.arg.isnt.array =\
    o segundo argumento para Fun\u00e7\u00e3o.prot\u00f3tipo.aplicar deve ser uma matriz
# NativeGlobal
msg.bad.esc.mask =\
     m\u00e1scara inv\u00e1lida para cadeia escapar 
     
# NativeJavaClass
msg.cant.instantiate =\
    erro ao instanciar ({0}): classe {1} \u00e9 interface ou abstrato


msg.bad.ctor.sig =\
    Encontrado construtor com assinatura errada: \
    {0} chamando {1} com assinatura {2}


msg.not.java.obj =\
    Esperava-se que o argumento para obterClasse() fosse um objeto Java. 


msg.no.java.ctor =\
    Construtor Java para "{0}" com argumentos "{1}" n\u00e3o encontrado.


# NativeJavaMethod
msg.method.ambiguous =\
    A combina\u00e7\u00e3o do m\u00e9todo Java {0}.{1} com argumentos JavaScript dos tipos ({2}) \u00e9 \ 
   amb\u00edgua; os m\u00e9todos expect\u00e1veis s\u00e3o: {3}


msg.constructor.ambiguous =\
    A combina\u00e7\u00e3o do construtor Java {0} com argumentos JavaScript dos tipos ({1}) \ 
    \u00e9 amb\u00edgua; os construtores expect\u00e1veis s\u00e3o: {2}


# NativeJavaObject
msg.conversion.not.allowed =\
    Imposs\u00edvel converter de {0} para {1}


msg.no.empty.interface.conversion =\
    Imposs\u00edvel converter {0} para interface {1} sem m\u00e9todos


msg.no.function.interface.conversion =\
    Imposs\u00edvel converter fun\u00e7\u00e3o {0} para interface porque cont\u00e9m m\u00e9todos com \
    assinaturas differentes


# NativeJavaPackage
msg.not.classloader =\
    Construtor para "Pacote" prev\u00ea argumento do tipo java.lang.Classloader


# NativeRegExp
msg.bad.quant =\
    Quantificador inv\u00e1lido {0}


msg.overlarge.backref =\
    Refer\u00eancia remissiva demasiado grande {0}


msg.overlarge.min =\
    M\u00ednimo demasiado grande {0}


msg.overlarge.max =\
    M\u00e1ximo demasiado grande {0}


msg.zero.quant =\
    Quantificador zero {0}


msg.max.lt.min =\
    M\u00e1ximo {0} menor que m\u00ednimo


msg.unterm.quant =\
    Quantificador n\u00e3o terminado {0}


msg.unterm.paren =\
    Quantificador parent\u00e9tico n\u00e3o terminado {0}


msg.unterm.class =\
    Classe de caracteres n\u00e3o terminada {0}


msg.bad.range =\
    Gama inv\u00e1lida em classe de caracteres.


msg.trail.backslash =\
    \ final numa express\u00e3o regular.


msg.re.unmatched.right.paren =\
    ) sem par numa express\u00e3o regular.


msg.no.regexp =\
    Express\u00f5es regulares n\u00e3o dispon\u00edveis.


msg.bad.backref =\
    Refer\u00eancia remissiva excede o n\u00famero de par\u00eanteses de captura.


msg.bad.regexp.compile =\
    Apenas um argumento pode ser especificado, se o primeiro argumento para \
    RegExp.prototype.compile for um objeto ExpReg .


# Parser
msg.got.syntax.errors = \
    Compila\u00e7\u00e3o produziu {0} erros de sintaxe.


msg.var.redecl =\
    ErroTipo: redeclara\u00e7\u00e3o da var {0}.


msg.const.redecl =\
    ErroTipo: redeclara\u00e7\u00e3o da constante {0}.
    
msg.let.redecl =\
    ErroTipo: redeclara\u00e7\u00e3o da var {0}.


msg.parm.redecl =\
    ErroTipo: redeclara\u00e7\u00e3o do par\u00e2metro formal {0}.


msg.fn.redecl =\
    ErroTipo: redeclara\u00e7\u00e3o da fun\u00e7\u00e3o {0}.


msg.let.decl.not.in.block =\
    ErroSintaxe: declara\u00e7\u00e3o dado n\u00e3o diretamente dentro do bloco


# NodeTransformer
msg.dup.label =\
    etiqueta duplicada


msg.undef.label =\
    etiqueta n\u00e3o definida


msg.bad.break =\
    quebra sem etiqueta deve estar dentro de um ciclo ou de um switch


msg.continue.outside =\
    continuar deve estar dentro de um ciclo


msg.continue.nonloop =\
    continuar s\u00f3 pode utilizar etiquetas de afirma\u00e7\u00f5es iterativas


msg.bad.throw.eol =\
    Terminador de linha n\u00e3o \u00e9 permitido entre a palavra-chave atirar e a express\u00e3o \
    atirar.


msg.no.paren.parms =\
    falta ( antes dos par\u00e2metros da fun\u00e7\u00e3o.


msg.no.parm =\
    falta par\u00e2metro formal


msg.no.paren.after.parms =\
    falta ) depois de par\u00e2metros formais


msg.no.brace.body =\
    falta '{' antes do corpo da fun\u00e7\u00e3o


msg.no.brace.after.body =\
    falta } depois do corpo da fun\u00e7\u00e3o


msg.no.paren.cond =\
    falta ( antes de condi\u00e7\u00e3o


msg.no.paren.after.cond =\
    falta ) depois de condi\u00e7\u00e3o


msg.no.semi.stmt =\
    falta ; antes de afirma\u00e7\u00e3o


msg.no.name.after.dot =\
    falta nome depois do operador . 


msg.no.name.after.coloncolon =\
    falta nome depois do operador : : 


msg.no.name.after.dotdot =\
    falta nome depois do operador .. 


msg.no.name.after.xmlAttr =\
    falta nome depois de .@


msg.no.bracket.index =\
    falta ] em express\u00e3o \u00edndice


msg.no.paren.switch =\
    falta ( antes da express\u00e3o switch


msg.no.paren.after.switch =\
    falta ) depois da express\u00e3o switch


msg.no.brace.switch =\
    falta '{' antes do corpo do switch


msg.bad.switch =\
    afirma\u00e7\u00e3o switch inv\u00e1lida


msg.no.colon.case =\
    falta : depois da expressi\u00e3o caso


msg.double.switch.default =\
    etiqueta duplicada de poromiss\u00e3o na afirma\u00e7\u00e3o switch


msg.no.while.do =\
    falta enquanto depois do corpo do ciclo-fazer


msg.no.paren.for =\
    falta ( depois de por


msg.no.semi.for =\
    falta ; depois de inicializador do ciclo-por


msg.no.semi.for.cond =\
    falta ; depois de condi\u00e7\u00e3o do ciclo-por 
    
msg.in.after.for.name =\
    falta em depois de nome do por


msg.no.paren.for.ctrl =\
    falta ) depois de controle do ciclo-por


msg.no.paren.with =\
    falta ( antes de objeto de afirma\u00e7\u00e3o-com


msg.no.paren.after.with =\
    falta ) depois de objeto de afirma\u00e7\u00e3o-com


msg.no.paren.after.let =\
    falta ( depois de dado


msg.no.paren.let =\
    falta ) depois da lista de vari\u00e1veis


msg.no.curly.let =\
    falta } depois de afirma\u00e7\u00e3o dado


msg.bad.return =\
    retorno inv\u00e1lido


msg.no.brace.block =\
    falta } em afirma\u00e7\u00e3o composta


msg.bad.label =\
    etiqueta inv\u00e1lida


msg.bad.var =\
    falta nome de vari\u00e1vel


msg.bad.var.init =\
    initializa\u00e7\u00e3o inv\u00e1lida de vari\u00e1vel


msg.no.colon.cond =\
    falta : em express\u00e3o condicional


msg.no.paren.arg =\
    falta ) depois da lista de argumentos


msg.no.bracket.arg =\
    falta ] depois da lista de elementos


msg.bad.prop =\
    identifica\u00e7\u00e3o de propriedade inv\u00e1lida


msg.no.colon.prop =\
    falta : depois da identifica\u00e7\u00e3o da propriedade


msg.no.brace.prop =\
    falta } depois da lista de propriedades


msg.no.paren =\
    falta ) em parent\u00e9tico


msg.reserved.id =\
    identificador \u00e9 uma palavra reservada


msg.no.paren.catch =\
    falta ( antes de condi\u00e7\u00e3o do bloco a apanhar


msg.bad.catchcond =\
    condi\u00e7\u00e3o inv\u00e1lida de bloco a apanhar 


msg.catch.unreachable =\
    quaisquer cla\u00fasulas do apanhar que se seguem a um apanhar n\u00e3o-qualificado \
    ficam inacess\u00edveis


msg.no.brace.try =\
    falta '{' antes de bloco de tentativa


msg.no.brace.catchblock =\
    falta '{' antes do corpo do bloco a apanhar


msg.try.no.catchfinally =\
    ''tentativa'' sem ''apanhar'' nem ''finalmente''


msg.no.return.value =\
  a fun\u00e7\u00e3o {0} nem sempre retorna um valor


msg.anon.no.return.value =\
  fun\u00e7\u00e3o an\u00f3nima nem sempre retorna um valor


msg.return.inconsistent =\
  afirma\u00e7\u00e3o de retorno \u00e9 incompat\u00edvel com utiliza\u00e7\u00e3o anterior


msg.generator.returns =\
  ErroTipo: fun\u00e7\u00e3o geradora {0} retorna um valor


msg.anon.generator.returns =\
  ErroTipo: fun\u00e7\u00e3o geradora an\u00f3nima retorna um valor


msg.syntax =\
    erro de sintaxe


msg.unexpected.eof =\
    Fim inesperado de ficheiro 


msg.XML.bad.form =\
    sintaxe XML com forma ilegal


msg.XML.not.available =\
    tempo de execu\u00e7\u00e3o XML indispon\u00edvel


msg.too.deep.parser.recursion =\
    Recorr\u00eancia demasiado profunda ao parsear


msg.no.side.effects =\
   O c\u00f3digo n\u00e3o tem efeitos colaterais


msg.extra.trailing.comma =\
    V\u00edrgula final \u00e9 ilegal num inicializador de objetos ECMA-262


msg.equal.as.assign =\
    Teste de igualdade (==) escrito como se fosse atribui\u00e7\u00e3o (=)?


msg.var.hides.arg =\
    Vari\u00e1vel{0} esconde argumento


msg.destruct.assign.no.init =\
    falta = em declara\u00e7\u00e3o desestruturadora


# ScriptRuntime
msg.no.properties =\
    {0} n\u00e3o tem propriedades.


msg.invalid.iterator =\
    Valor inv\u00e1lido de iterador


msg.iterator.primitive =\
    __iterador__ retornou um valor primitivo


msg.assn.create.strict =\
    Atribui\u00e7\u00e3o para vari\u00e1vel n\u00e3o declarada {0}


msg.ref.undefined.prop =\
    Refer\u00eancia a propriedade n\u00e3o definida "{0}"


msg.prop.not.found =\
    Propriedade {0} n\u00e3o encontrada.


msg.set.prop.no.setter =\
    N\u00e3o pode atualizar propriedade {0} que apenas tem leitor.


msg.invalid.type =\
    Valor JavaScript de tipo {0} inv\u00e1lido


msg.primitive.expected =\
    Esperava-se tipo primitivo (em vez disso, tinha {0} )


msg.namespace.expected =\
    Esperava-se objeto espa\u00e7o de nome \u00e0 esquerda de :: (em vez disso, encontrou {0} )


msg.null.to.objeto =\
    N\u00e3o pode converter nulo em objeto.


msg.undef.to.object =\
    N\u00e3o pode converter indefinido em objeto.


msg.cyclic.value =\
    Valor {0} c\u00edclico n\u00e3o \u00e9 permitido.


msg.is.not.defined =\
    "{0}" n\u00e3o est\u00e1 definido.


msg.undef.prop.read =\
    N\u00e3o pode ler propriedade "{1}" de {0}


msg.undef.prop.write =\
    N\u00e3o pode atualizar propriedade "{1}" de {0} para "{2}"


msg.undef.prop.delete =\
    N\u00e3o pode eliminar propriedade "{1}" de {0}


msg.undef.method.call =\
    N\u00e3o pode chamar m\u00e9todo "{1}" de {0}


msg.undef.with =\
    N\u00e3o pode aplicar "com" a {0}


msg.isnt.function =\
    {0} n\u00e3o \u00e9 uma fun\u00e7\u00e3o, \u00e9 {1}.


msg.isnt.function.in =\
    N\u00e3o pode chamar propriedade {0} no objeto {1}. N\u00e3o \u00e9 uma fun\u00e7\u00e3o, \u00e9 "{2}".
msg.function.not.found =\
    N\u00e3o encontra fun\u00e7\u00e3o {0}.


msg.function.not.found.in =\
    N\u00e3o encontra fun\u00e7\u00e3o {0} no objeto {1}.


msg.isnt.xml.object =\
    {0} n\u00e3o \u00e9 um objeto xml.


msg.no.ref.to.get =\
    {0} n\u00e3o \u00e9 uma refer\u00eancia para ler valor de refer\u00eancia.


msg.no.ref.to.set =\
    {0} n\u00e3o \u00e9 uma refer\u00eancia para atualizar valor de refer\u00eancia para {1}.


msg.no.ref.from.function =\
    Fun\u00e7\u00e3o {0} n\u00e3o pode ser usada como lado esquerdo da atribui\u00e7\u00e3o \
    nem como operando de operador  ++ ou -- .
    
msg.bad.default.value =\
    O m\u00e9todo lerValorDefeito() do objeto retornou um objeto.


msg.instanceof.not.object = \
    N\u00e3o pode usar inst\u00e2nciade num n\u00e3o-objeto.


msg.instanceof.bad.prototype = \
    propriedade ''prot\u00f3tipo'' de {0} n\u00e3o \u00e9 um objeto.


msg.bad.radix = \
    ra\u00edz {0} inv\u00e1lida.


# ScriptableObject
msg.default.value =\
    N\u00e3o encontrou valor-defeito para o objeto.


msg.zero.arg.ctor =\
    N\u00e3o pode carregar classe "{0}" que n\u00e3o tenha construtor de zero par\u00e2metros.


duplicate.defineClass.name =\
    M\u00e9todo inv\u00e1lido "{0}": o nome "{1}" j\u00e1 foi utilizado.


msg.ctor.multiple.parms =\
    N\u00e3o pode definir construtor ou classe {0} porque h\u00e1 mais do que um \
    construtor com v\u00e1rios par\u00e2metros.
 
msg.extend.scriptable =\
    {0} deve expandir ObjetoScript\u00e1vel para definir {1}.


msg.bad.getter.parms =\
    Para definir uma propriedade, o leitor {0} deve ter zero par\u00e2metros \
    ou um \u00fanico par\u00e2metro ObjetoScript\u00e1vel.


msg.obj.getter.parms =\
    Esperava-se que o leitor est\u00e1tico ou delegado {0} levasse par\u00e2metro de ObjetoScript\u00e1vel.


msg.getter.static =\
    Leitor e atualizador devem ser ambos est\u00e1ticos, ou ent\u00e3o nenhum deles pode ser est\u00e1tico.


msg.setter.return =\
    Atualizador deve ter retorno vazio tipo {0}


msg.setter2.parms =\
    Atualizador de dois par\u00e2metros deve levar ObjetoScript\u00e1vel como primeiro par\u00e2metro.


msg.setter1.parms =\
    Esperava-se atualizador de um s\u00f3 par\u00e2metro para {0}


msg.setter2.expected =\
    Esperava-se que o atualizador est\u00e1tico ou delegado {0} levasse dois par\u00e2metros.


msg.setter.parms =\
   Esperava-se um ou dois par\u00e2metros para o atualizador.


msg.setter.bad.type =\
    Par\u00e2metro inv\u00e1lido tipo "{0}" no atualizador "{1}".


msg.add.sealed =\
    N\u00e3o pode adicionar uma propriedade a um objeto selado: {0}.


msg.remove.sealed =\
    N\u00e3o pode retirar uma propriedade de um objeto selado: {0}.


msg.modify.sealed =\
    N\u00e3o pode modificar uma propriedade de um objeto selado: {0}.


msg.modify.readonly =\
    N\u00e3o pode modificar propriedade de consulta: {0}.


# TokenStream
msg.missing.exponent =\
    falta expoente 


msg.caught.nfe =\
    erro no formato de um n\u00famero


msg.unterminated.string.lit =\
   literal de cadeia n\u00e3o terminada


msg.unterminated.coment\u00e1rio =\
   coment\u00e1rio n\u00e3o terminado


msg.unterminated.re.lit =\
     literal de express\u00e3o regular n\u00e3o terminada


msg.invalid.re.flag =\
    indicador inv\u00e1lido depois de express\u00e3o regular 


msg.no.re.input.for =\
    n\u00e3o h\u00e1 valores de entrada para {0}


msg.illegal.character =\
    caractere ilegal


msg.invalid.escape =\
   sequ\u00eancia Unicode de escapar inv\u00e1lida


msg.bad.namespace =\
    afirma\u00e7\u00e3o inv\u00e1lida sobre espa\u00e7o de nomes de defeito. \
    A sintaxe \u00e9: espa\u00e7o de nomes defeito xml = EXPRESS\u00c3O;


# TokensStream warnings
msg.bad.octal.literal =\
    d\u00edgito octal literal ilegal {0}; interpretando como d\u00edgito decimal


msg.reserved.keyword =\
   utiliza\u00e7\u00e3o ilegal de futura palavra-chave reservada {0}; interpretando como um \ 
   identificador normal


# LiveConnect errors
msg.java.internal.field.type =\
    Erro interno: tipo conversion of {0} to assign to {1} on {2} failed.
   
msg.java.conversion.implicit_method =\
    N\u00e3o encontra m\u00e9todo de convers\u00e3o "{0}" na classe {1}.


msg.java.method.assign =\
    O m\u00e9todo Java "{0}" n\u00e3o pode receber atribui\u00e7\u00f5es.


msg.java.internal.private =\
    Erro interno: tentou aceder a campo privado/protegido "{0}".


msg.java.no_such_method =\
     N\u00e3o encontra m\u00e9todo {0}.


msg.script.is.not.constructor =\
    Objetos do script n\u00e3o s\u00e3o construtores.


msg.nonjava.method =\
    O m\u00e9todo Java "{0}" foi invocado com {1} como "este" valor que n\u00e3o pode \ 
    ser convertido para  tipo Java {2}.
    
msg.java.member.not.found =\
    A classe Java "{0}" n\u00e3o tem campo de inst\u00e2ncia p\u00fablica nem m\u00e9todo chamado "{1}".


msg.java.array.index.out.of.bounds =\
      \u00cdndice {0} da matriz est\u00e1 inacess\u00edvel [0..{1}].


msg.java.array.member.not.found =\
    As matrizes Java n\u00e3o t\u00eam campos de inst\u00e2ncia p\u00fablica nem m\u00e9todos chamados "{0}".


msg.pkg.int =\
    Os nomes de pacotes do Java n\u00e3o podem ser num\u00e9ricos.


msg.access.prohibited =\
    Accesso \u00e0 classe "{0}" do Java \u00e9 proibido.


# ImporterTopLevel
msg.ambig.import =\
    Importa\u00e7\u00e3o amb\u00edgua: "{0}" e "{1}".
msg.not.pkg =\
    Fun\u00e7\u00e3o importarPacote deve ser chamada com um pacote; em vez disso, tinha"{0}".


msg.not.class =\
    Fun\u00e7\u00e3o importarClasse deve ser utilizada com uma classe; em vez disso, tinha"{0}".


msg.not.class.not.pkg =\
    "{0}" n\u00e3o \u00e9 classe nem pacote.


msg.prop.defined =\
    N\u00e3o pode importar "{0}" porque a propriedade com esse nome  j\u00e1 foi definida.


#JavaAdapter
msg.adapter.zero.args =\
    O AdaptadorJava exige pelo menos um argumento.


msg.not.java.class.arg = \
Argumento {0} n\u00e3o \u00e9 classe: {1} do Java.
#JavaAdapter
msg.only.one.super = \
   Apenas uma classe pode ser expandida por um AdaptadorJava. Tinha {0} e {1}.


# Arrays
msg.arraylength.bad =\
   Comprimento de matriz inapropriado.


# Arrays
msg.arraylength.too.big =\
    Comprimento da matriz {0} excede o limite de capacidade previsto.


# URI
msg.bad.uri =\
   Sequ\u00eancia URI mal formada


# Number
msg.bad.precision =\
    Precis\u00e3o {0} fora da gama.


# NativeGenerator
msg.send.newborn =\
  Tentativa de enviar valor para um gerador rec\u00e9m-criado


msg.already.exec.gen =\
    J\u00e1 a executar gerador
    
msg.StopIteration.invalid =\
    PararItera\u00e7\u00e3o n\u00e3o pode ser alterado para um objeto qualquer.


# Interpreter
msg.yield.closing =\
 Ceder do gerador de fecho


# New Babylscript Stuff
msg.unknown.language.mode =\
  Modo de linguagem desconhecido
